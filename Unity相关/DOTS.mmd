[Scia Reto](https://sciareto.org) mind map   
> __version__=`1.1`,showJumps=`true`
---

# Root topic

## DOTS

### 全称为Data Oriented Technology Stack

#### 面向 数据的技术栈

### 包含哪些技术栈

#### Entities\(ECS\)

##### Entity是作为一个索引或者Id

##### Components

###### 每种Entity所有组件的组合称为一个ArcheType

###### 以Chunk的形式存储在Ram

####### 16kb

###### 相同ArcheType的会存储在相同Chunk上

###### ECB\.SetComponent 只能用来覆盖之前已经有的组件，如果之前没有会有奇怪报错<br/>如果只是添加可以用ECB\.AddComponent
> fillColor=`#FF0E00`


##### Systems

###### 要指定那些组合的更新

###### 每帧的System分组

####### Initializaiton

####### Simulation

####### Presentation

####### UpdateInGroup 标签来指定

###### AutomticBootstraping

####### 只有在项目里面定义了的都会被创建

####### 可以在OnCreate里面用的state\.RequireForUpdate，<br/>来控制某个System 是否要执行update

######## 官方的ExecuteAuthoring 脚本就是演示了这种控制机制

#### Job System 

##### Unity 里面的多线程系统

###### 可其他的DOTS模块不一样,JobSystem 是自带在Unity的CoreModule的

##### Jobs are scheduled on the Main Thread
> fillColor=`#00FF49`


###### Unity管理了Worker Threadd的池子，主线程占一个核<br/>，剩下的每个核有一个对应的Worker Thread
> fillColor=`#00FF49`


###### Worker thread execut jobs from the job queue when available

###### 一旦job开始在Worker线程运行，会一直执行到结束（not preempted
> fillColor=`#00FF49`


##### 依赖管理

##### Job 的运行方式

###### Run（） 立刻在主线程运行

###### Schedule\(\) 安排在一个worker thread 运行

###### ScheduleParallel（）安排和其他的jobs 并行的运行在多个Worker

##### IJob

###### Execute生命了哪些参数，底层的Source Generator就会自动帮生成需要符合函数参数的query

###### IJobEntity 和IJobChunk的区别

####### IJobChunk 在Schedule之前必须手动做一次query，<br/>并且把query的结果作为参数传给Schedule

##### 控制job运行的一些条件标签

###### WithNone

####### 没有指定类型组件的才运行

###### WithAll

####### 有指定类型组件的才运行

#### BurstCompiler

##### 编译阶段的优化

###### Burst是第三个编译器选项

####### 默认的两个编译器

######## Mono

######### JIT

######## IL2CPP

######### AOT

########## 性能更好，在一些平台的支持更好

##### SIMD

###### Burst能提升性能的原因

##### Only  workers with blittable, unmanagered data types

###### blittable ?

####### 只能用基本类型做的数据，不能用类的数据

#### Other Packages

##### Math

###### Unity\.Mathematics

####### Burst optimized

####### 这个库的欧拉角函数用的是弧度值，Transform返回的是角度，要同步的话注意转换

####### quaternion\.Euler 默认的顺序是ZXY，跟常规的xyz 不一样！！！

####### Unity\.Mathematics cheat sheet
- LINK
<pre>https://github.com/Unity-Technologies/EntityComponentSystemSamples/blob/master/EntitiesSamples/Docs/cheatsheet/mathematics.md</pre>

##### Collections

###### Unity\.Collections

###### provides unmanged collection types

####### 数据类型分类

######## Native开头的

######### 操作会执行安全检查，有问题会抛异常和错误

######## Unsafe开头的

######### 不执行安全检查

######## 不符合上面的都是struct ，没有allocate 也就不需要释放

##### Graphics

###### Unity\.Graphics

####### Render entities

######## HRP/HDRP only

## 教程的步骤
> collapsed=`true`,leftSide=`true`


### 创建SubScene,在SubScene创建的对象会自动有成为Entity的切换项
> collapsed=`true`


#### Inspector可以预览，Entity的属性，<br/>也可以预览作为Game Object的属性，右上角切换

### 改了Brain材质要关闭开启SubScene才能看到
> leftSide=`true`


### SubScene要勾选OpenForEditing才能看到里面的对象
> leftSide=`true`


### 在场景用增加Graveyard
> collapsed=`true`


#### GraveyardProperties
> collapsed=`true`


##### ESC数据，没法直接挂到Mono上

#### Graveyard Mono
> collapsed=`true`,leftSide=`true`


##### 就是常规的用来挂数据的脚本

#### GraveyardBaker
> collapsed=`true`,leftSide=`true`


##### 指定怎么把Mono转成ECS的数据

#### 引入Aspect的概念
> collapsed=`true`


##### 相当于ECS版本的Transform组件？

##### 不只是Transform，还可以用来整合个各种属性,让query 更简单

### 加入System
> collapsed=`true`


#### 要加BurstCompile 标签

#### UpdateInGroup 来指定要在哪个SystemGroup执行

#### OnUpdate里面 state\.Enabled = false; 可以让脚本只执行一次

#### System只要声明运行的时候就会被加到运行逻辑里面，不需要显示实例化或者添加

#### state\.RequireForUpdate 控制执行顺序

#### tombstone随机设置transform
> collapsed=`true`


##### UniformScaleTransform

##### 设置到Entity上 
> collapsed=`true`


######   var newTombstoneTransform = graveyard\.GetRandomTombstoneTransform\(\);<br/> ecb\.SetComponent\(newTombstone,new LocalToWorldTransform\{Value = newTombstoneTransform\}\);

### 墓碑上的材质随机
> collapsed=`true`


#### Material Property Override

### 在墓碑生成僵尸
> collapsed=`true`,leftSide=`true`


#### IJobEntity

### 僵尸AI
> collapsed=`true`


#### ScheduleParallel 的时序依赖
> collapsed=`true`


##### UpdateAfter 标签指定要在哪个system之后运行

#### EntityCommandBuffer\.ParallelWriter

#### EndInitializationEntityCommandBufferSystem
> collapsed=`true`


##### spawn是begin 这个是end

#### RemoveComponent 移除组件需要用到sortkey

#### 让僵尸动起来
> collapsed=`true`


##### IEnableableComponent

### 脑子扣血逻辑
> collapsed=`true`


#### DynamicBuffer

### 脑子变小后，停住的僵尸要再走近的逻辑
> leftSide=`true`


### 摄像机逻辑
> collapsed=`true`,leftSide=`true`


#### Mono实现

## Allocator
> leftSide=`true`


### 如果只是在函数内分配的内存，用temp就行

### 如果要持续存在就用Persistent
> leftSide=`true`


## 官方文档
- LINK
<pre>https://docs.unity3d.com/Packages/com.unity.entities@1.2/manual/ecs-workflow-intro.html</pre>

### Hybrid CLR相关
- LINK
<pre>https://hybridclr.doc.code-philosophy.com/en/docs/basic/dots</pre>

### GitHub官方例子
- LINK
<pre>https://github.com/Unity-Technologies/EntityComponentSystemSamples</pre>

## BlobAssets
> leftSide=`true`


## SystemAPI
> leftSide=`true`


### Query

#### 底层是sourceGenerator  返回符合查询要求的Iterator

### Time

### 根据Entity 查询Component

####  SystemAPI\.GetComponentLookup\<T\>\(\)得到ComponentLookup，<br/>然后就可以传Entity 作为id去查询了

## Aspect

### Component里面定义的值在Job里面直接修改是无效的，<br/>需要用RefRW 封装一下，但是RefRW又不允许作为Component 字段

### Aspect里面生命的Ref组件要全部都能在一个Entity身上找到<br/>声明了Aspect作为参数的Job才能找到匹配

## 改变组件状态的方式对比

### Value

#### 通过修改组件的值来做不同的分支行为，<br/>数量多的话还是得全部运行

### Structural

#### 通过动态增删组件

##### 时间少了，但是增删组件有消耗<br/>因为增删组件就得把组件移动到不同的Chunk<br/>优点是如果变化不频繁，后续查询会快点

### EnableComponent

#### 通过切换组件的启用状态来实现

### 不同情景用不同的策略

## DOTS 动画处理
> leftSide=`true`


### YouTube
- LINK
<pre>https://www.youtube.com/watch?v=KvabbZKrUHk&amp;ab_channel=TurboMakesGames</pre>

### Rukhanka \- ECS Animation System
- LINK
<pre>https://assetstore.unity.com/packages/tools/animation/rukhanka-ecs-animation-system-241472?aid=1101l9vRP&amp;utm_campaign=unity_affiliate&amp;utm_medium=affiliate&amp;utm_source=partnerize-linkmaker</pre>

## SubScene And Baking

### 每次重新运行或者编辑都会信息baking
