[Scia Reto](https://sciareto.org) mind map   
> __version__=`1.1`,showJumps=`true`
---

# Root topic

## DOTS
> collapsed=`true`


### 全称为Data Oriented Technology Stack
> collapsed=`true`


#### 面向 数据的技术栈

### 包含哪些技术栈
> collapsed=`true`


#### Entities\(ECS\)
> collapsed=`true`


##### Entity是作为一个索引或者Id

##### Components
> collapsed=`true`


###### 每种Entity所有组件的组合称为一个ArcheType

###### 以Chunk的形式存储在Ram
> collapsed=`true`


####### 16kb

###### 相同ArcheType的会存储在相同Chunk上

##### Systems
> collapsed=`true`


###### 要指定那些组合的更新

###### 每帧的System分组
> collapsed=`true`


####### Initializaiton

####### Simulation

####### Presentation

####### UpdateInGroup 标签来指定

###### AutomticBootstraping
> collapsed=`true`


####### 只有在项目里面定义了的都会被创建

####### 可以在OnCreate里面用的state\.RequireForUpdate，<br/>来控制某个System 是否要执行update
> collapsed=`true`


######## 官方的ExecuteAuthoring 脚本就是演示了这种控制机制

#### Job System 
> collapsed=`true`


##### Unity 里面的多线程系统

##### Jobs are scheduled on the Main Thread
> fillColor=`#00FF49`


##### Worker thread execut jobs from the job queue when available

##### 依赖管理

##### Job 的运行方式
> collapsed=`true`


###### Run（） 立刻在主线程运行

###### Schedule\(\) 安排在一个worker thread 运行

###### ScheduleParallel（）安排和其他的jobs 并行的运行在多个Worker

##### IJob
> collapsed=`true`


###### Execute生命了哪些参数，底层的Source Generator就会自动帮生成需要符合函数参数的query

###### IJobEntity 和IJobChunk的区别
> collapsed=`true`


####### IJobChunk 在Schedule之前必须手动做一次query，<br/>并且把query的结果作为参数传给Schedule

##### 控制job运行的一些条件标签
> collapsed=`true`


###### WithNone
> collapsed=`true`


####### 没有指定类型组件的才运行

###### WithAll
> collapsed=`true`


####### 有指定类型组件的才运行

#### BurstCompiler
> collapsed=`true`


##### 编译阶段的优化

##### SIMD
> collapsed=`true`


###### 

##### Only  workers with blittable, unmanagered data types
> collapsed=`true`


###### blittable ?
> collapsed=`true`


####### 只能用基本类型做的数据，不能用类的数据

#### Other Packages
> collapsed=`true`


##### Math
> collapsed=`true`


###### Unity\.Mathematics
> collapsed=`true`


####### Burst optimized

##### Collections
> collapsed=`true`


###### Unity\.Collections

##### Graphics
> collapsed=`true`


###### Unity\.Graphics
> collapsed=`true`


####### Render entities
> collapsed=`true`


######## HRP/HDRP only

## 教程的步骤
> collapsed=`true`,leftSide=`true`


### 创建SubScene,在SubScene创建的对象会自动有成为Entity的切换项
> collapsed=`true`


#### Inspector可以预览，Entity的属性，<br/>也可以预览作为Game Object的属性，右上角切换

### 改了Brain材质要关闭开启SubScene才能看到
> leftSide=`true`


### SubScene要勾选OpenForEditing才能看到里面的对象
> leftSide=`true`


### 在场景用增加Graveyard
> collapsed=`true`


#### GraveyardProperties
> collapsed=`true`


##### ESC数据，没法直接挂到Mono上

#### Graveyard Mono
> collapsed=`true`,leftSide=`true`


##### 就是常规的用来挂数据的脚本

#### GraveyardBaker
> collapsed=`true`,leftSide=`true`


##### 指定怎么把Mono转成ECS的数据

#### 引入Aspect的概念
> collapsed=`true`


##### 相当于ECS版本的Transform组件？

##### 不只是Transform，还可以用来整合个各种属性,让query 更简单

### 加入System
> collapsed=`true`


#### 要加BurstCompile 标签

#### UpdateInGroup 来指定要在哪个SystemGroup执行

#### OnUpdate里面 state\.Enabled = false; 可以让脚本只执行一次

#### System只要声明运行的时候就会被加到运行逻辑里面，不需要显示实例化或者添加

#### state\.RequireForUpdate 控制执行顺序

#### tombstone随机设置transform
> collapsed=`true`


##### UniformScaleTransform

##### 设置到Entity上 
> collapsed=`true`


######   var newTombstoneTransform = graveyard\.GetRandomTombstoneTransform\(\);<br/> ecb\.SetComponent\(newTombstone,new LocalToWorldTransform\{Value = newTombstoneTransform\}\);

### 墓碑上的材质随机
> collapsed=`true`


#### Material Property Override

### 在墓碑生成僵尸
> collapsed=`true`,leftSide=`true`


#### IJobEntity

### 僵尸AI
> collapsed=`true`


#### ScheduleParallel 的时序依赖
> collapsed=`true`


##### UpdateAfter 标签指定要在哪个system之后运行

#### EntityCommandBuffer\.ParallelWriter

#### EndInitializationEntityCommandBufferSystem
> collapsed=`true`


##### spawn是begin 这个是end

#### RemoveComponent 移除组件需要用到sortkey

#### 让僵尸动起来
> collapsed=`true`


##### IEnableableComponent

### 脑子扣血逻辑
> collapsed=`true`


#### DynamicBuffer

### 脑子变小后，停住的僵尸要再走近的逻辑
> leftSide=`true`


### 摄像机逻辑
> collapsed=`true`,leftSide=`true`


#### Mono实现

## Allocator
> leftSide=`true`


### 如果只是在函数内分配的内存，用temp就行

### 如果要持续存在就用Persistent
> leftSide=`true`


## 官方文档
- LINK
<pre>https://docs.unity3d.com/Packages/com.unity.entities@1.2/manual/ecs-workflow-intro.html</pre>

### Hybrid CLR相关
- LINK
<pre>https://hybridclr.doc.code-philosophy.com/en/docs/basic/dots</pre>

### GitHub官方例子
- LINK
<pre>https://github.com/Unity-Technologies/EntityComponentSystemSamples</pre>

## BlobAssets
> leftSide=`true`


## SystemAPI
> leftSide=`true`


### Query

#### 底层是sourceGenerator  返回符合查询要求的Iterator

### Time

## Aspect

### Component里面定义的值在Job里面直接修改是无效的，<br/>需要用RefRW 封装一下，但是RefRW又不允许作为Component 字段

### Aspect里面生命的Ref组件要全部都能在一个Entity身上找到<br/>声明了Aspect作为参数的Job才能找到匹配

## 改变组件状态的方式对比

### Value

#### 通过修改组件的值来做不同的分支行为，<br/>数量多的话还是得全部运行

### Structural

#### 通过动态增删组件

##### 时间少了，但是增删组件有消耗<br/>因为增删组件就得把组件移动到不同的Chunk<br/>优点是如果变化不频繁，后续查询会快点

### EnableComponent

#### 通过切换组件的启用状态来实现

### 不同情景用不同的策略

## DOTS 动画处理
> leftSide=`true`


### YouTube
- LINK
<pre>https://www.youtube.com/watch?v=KvabbZKrUHk&amp;ab_channel=TurboMakesGames</pre>

### Rukhanka \- ECS Animation System
- LINK
<pre>https://assetstore.unity.com/packages/tools/animation/rukhanka-ecs-animation-system-241472?aid=1101l9vRP&amp;utm_campaign=unity_affiliate&amp;utm_medium=affiliate&amp;utm_source=partnerize-linkmaker</pre>
